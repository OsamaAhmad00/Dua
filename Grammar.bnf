// Using the Syntax language-agnostic parser generator (syntax-cli).
//  You can find it at https://github.com/DmitrySoshnikov/syntax
//  Command: syntax-cli -g Grammar.bnf -m LALR1 -o Parser.h


// Lexical Grammar -------------------------------------------

%lex

%%

// Whitespaces
\s+                 %empty

// Comments
\/\/.*              %empty
\/\*[\s\S]*?\*\/    %empty

\d+                 NUMBER

[\w\-+*/!=<>]+      SYMBOL

\"[^\"]*\"          STRING

/lex


// Syntactic Grammar -----------------------------------------

%{

#include "Expression.h"

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// FIXME PASS POINTERS INSTEAD OF MAKING A COPY ON EACH ASSIGNMENT
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// The Syntax tool expects the final result to be of type "Value",
//  thus, as a quick solution, we're type-aliasing.
using Value = Expression;

%}

%%

Expression: Atom
          | List
          ;

// The list owning the expressions is responsible for deleting them.
Atom: SYMBOL { $$ = Expression(SExpressionType::SYMBOL, $1) }
    | STRING { $$ = Expression(SExpressionType::STRING, $1.substr(1, $1.size() - 2)) }
    | NUMBER { $$ = Expression(std::stoll($1)) }
    ;

List: '(' ListEntries ')' { $$ = $2 }
    ;

ListEntries: %empty                 { $$ = Expression(std::vector<Expression>()) }
           | ListEntries Expression { $1.list.push_back($2); $$ = $1 }
           ;