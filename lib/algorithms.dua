import "random.dua"

int c_comparator_converter<T, Comparator>(T* a, T* b)
{
    Comparator cmp;
    return cmp.compare(*a, *b);
}

void sort<T, Comparator>(T* base, long n)
{
    qsort(((int*))base, n, sizeof(T), ((int(int*, int*)*))c_comparator_converter<T, Comparator>);
}

class ascending_comparator<T>
{
    int compare(T& a, T& b)
    {
        if (a < b) {
            return -1;
        }

        // If both a < b == false and b < a == false, then a = b
        return b < a;
    }
}

class descending_comparator<T>
{
    int compare(T& a, T& b)
    {
        if (b < a) {
            return -1;
        }

        // If both a < b == false and b < a == false, then a = b
        return a < b;
    }
}

void sort_ascending<T>(T* base, long n)
{
    sort<T, ascending_comparator<T>>(base, n);
}

void sort_descending<T>(T* base, long n)
{
    sort<T, descending_comparator<T>>(base, n);
}

class random_comparator<T>
{
    int compare(T& a, T& b)
    {
        return (random_int() % 2) ? 1 : -1;
    }
}

void shuffle<T>(T* base, long n)
{
    sort<T, random_comparator<T>>(base, n);
}

void reverse<T>(T* base, long n)
{
    long i = 0;
    long j = n - 1;
    while (i < j)
    {
        T temp = base[i];
        base[i] = base[j];
        base[j] = temp;
        i++;
        j--;
    }
}

nomangle void qsort(int* base, long n, long size, int(int*, int*)* comparator);
