import "execution.dua"

class Vector<T>
{
    typealias size_t = long;

    size_t _size = 0;
    size_t _capacity;
    T* buffer;

    constructor(size_t n) : _capacity(n), buffer(n > 0 ? new[n] T : null)
    {
        if (_size < 0) panic("The Vector class can't have negative size");
    }

    constructor(size_t n, T value)
    {
        constructor(n);
        for (size_t i = 0; i < n; i++)
            buffer[i] = value;
        _size = n;
    }

    constructor() { constructor(2); }

    size_t size() { return _size; }

    size_t capacity() { return _capacity; }

    void push(T t) {
        expand_if_needed();
        buffer[_size++] = t;
    }

    T pop() {
        if (_size == 0)
            panic("Can't pop an empty vector");
        return buffer[--_size];
    }

    T& postfix [](size_t i) {
        if (i < 0)
            panic("Can't have a negative index\n");
        if (i >= _size)
            panic("Can't have an index bigger than the size\n");
        return buffer[i];
    }

    void expand_if_needed()
    {
        if (_size == _capacity)
            alloc_new_buffer(_size * 2);
    }

    void trim_to_fit()
    {
        if (_size > 0)
            alloc_new_buffer(_size);
    }

    void alloc_new_buffer(size_t new_capacity)
    {
        if (new_capacity <= 0)
            panic("Cannot allocate a non-positive-sized buffer");

        T* temp = new[new_capacity] T;

        for (size_t i = 0; i < _size; i++)
            temp[i] = buffer[i];

        delete buffer;
        buffer = temp;

        _capacity = new_capacity;
    }

    void resize(size_t new_size)
    {
        if (new_size <= 0)
            panic("Cannot resize to a non-positive size");

        if (new_size > _capacity)
            alloc_new_buffer(new_size);

        _size = new_size;
    }

    void reserve(size_t amount)
    {
        if (amount <= 0)
            panic("Cannot reserve a non-positive amount");

        if (amount <= _capacity)
            return;

        alloc_new_buffer(amount);
    }

    void delete_buffer()
    {
        // FIXME remove this function and delete the buffer
        //  in the destructor. This is needed to not be in
        //  the destructor so that the vector can be passed
        //  from one scope to the other without deleting the
        //  buffer. Nevertheless, this will cause memory
        //  leaks if the users didn't delete all allocated
        //  buffers manually.
        delete buffer;
    }
}

